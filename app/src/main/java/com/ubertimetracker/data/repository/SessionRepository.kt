package com.ubertimetracker.data.repository

import com.ubertimetracker.data.local.PauseDao
import com.ubertimetracker.data.local.SessionDao
import com.ubertimetracker.data.model.*
import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import java.time.DayOfWeek
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.format.DateTimeFormatter
import java.time.format.TextStyle
import java.time.temporal.TemporalAdjusters
import java.time.temporal.WeekFields
import java.util.*
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SessionRepository @Inject constructor(
    private val sessionDao: SessionDao,
    private val pauseDao: PauseDao
) {

    fun getAllSessions(): Flow<List<Session>> = sessionDao.getAllSessions()

    fun getSessionsByDate(date: LocalDate): Flow<List<Session>> = 
        sessionDao.getSessionsByDate(date)

    fun getSessionsForMonth(year: Int, month: Int): Flow<List<Session>> =
        sessionDao.getSessionsByMonth(
            year.toString(),
            month.toString().padStart(2, '0')
        )

    suspend fun getSessionById(id: Long): Session? = sessionDao.getSessionById(id)

    suspend fun getSessionForDate(date: LocalDate): Session? = 
        sessionDao.getSessionForDate(date)

    suspend fun createSession(
        date: LocalDate = LocalDate.now(),
        startTime: LocalTime = LocalTime.now()
    ): Long {
        val session = Session(
            date = date,
            startTime1 = startTime,
            stopTime1 = null,
            startTime2 = null,
            stopTime2 = null,
            isAutoGenerated = false,
            createdAt = LocalDateTime.now(),
            updatedAt = LocalDateTime.now()
        )
        return sessionDao.insertSession(session)
    }

    suspend fun updateSession(session: Session) {
        val updatedSession = session.copy(
            updatedAt = LocalDateTime.now(),
            totalHours = calculateTotalHours(session)
        )
        sessionDao.updateSession(updatedSession)
    }

    suspend fun stopSession(sessionId: Long, stopTime: LocalTime = LocalTime.now()) {
        val session = sessionDao.getSessionById(sessionId) ?: return
        
        val updatedSession = if (session.stopTime1 == null) {
            session.copy(stopTime1 = stopTime)
        } else {
            session.copy(stopTime2 = stopTime)
        }
        
        val withTotalHours = updatedSession.copy(
            totalHours = calculateTotalHours(updatedSession),
            updatedAt = LocalDateTime.now()
        )
        
        sessionDao.updateSession(withTotalHours)
    }

    suspend fun resumeSession(sessionId: Long, resumeTime: LocalTime = LocalTime.now()) {
        val session = sessionDao.getSessionById(sessionId) ?: return
        
        if (session.stopTime1 != null && session.startTime2 == null) {
            val updatedSession = session.copy(
                startTime2 = resumeTime,
                updatedAt = LocalDateTime.now()
            )
            sessionDao.updateSession(updatedSession)
        }
    }

    suspend fun addPause(sessionId: Long, startTime: LocalTime = LocalTime.now()): Long {
        val pause = Pause(
            sessionId = sessionId,
            startTime = startTime,
            endTime = null
        )
        return pauseDao.insertPause(pause)
    }

    suspend fun endPause(pauseId: Long, endTime: LocalTime = LocalTime.now()) {
        val pause = pauseDao.getPauseById(pauseId) ?: return
        val duration = java.time.Duration.between(pause.startTime, endTime).toMinutes()
        
        pauseDao.updatePause(pause.copy(
            endTime = endTime,
            durationMinutes = duration
        ))
        
        // Update session's total pause duration
        val totalPause = pauseDao.getTotalPauseDuration(pause.sessionId) ?: 0
        val session = sessionDao.getSessionById(pause.sessionId) ?: return
        sessionDao.updateSession(session.copy(
            totalPauseDuration = totalPause,
            updatedAt = LocalDateTime.now()
        ))
    }

    suspend fun getActivePause(sessionId: Long): Pause? = 
        pauseDao.getActivePause(sessionId)

    fun getPausesForSession(sessionId: Long): Flow<List<Pause>> = 
        pauseDao.getPausesForSession(sessionId)

    suspend fun deleteSession(session: Session) {
        pauseDao.deletePausesForSession(session.id)
        sessionDao.deleteSession(session)
    }

    suspend fun clearAllData() {
        pauseDao.deleteAllPauses()
        sessionDao.deleteAllSessions()
    }

    suspend fun updateSessionEndTime(sessionId: Long, endTime: LocalTime?) {
        val session = sessionDao.getSessionById(sessionId) ?: return
        
        // In the "Single Span + Logs" model, we always update stopTime1
        // as the "Current End of Day". startTime2/stopTime2 are deprecated/unused for now.
        val updatedSession = session.copy(
            stopTime1 = endTime,
            updatedAt = LocalDateTime.now()
        )
        
        // Recalculate total hours immediately
        val withHours = updatedSession.copy(
            totalHours = calculateTotalHours(updatedSession)
        )
        
        sessionDao.updateSession(withHours)
    }

    suspend fun getTotalHoursForMonth(year: Int, month: Int): Double {
        val startDate = LocalDate.of(year, month, 1)
        val endDate = startDate.with(TemporalAdjusters.lastDayOfMonth())
        return sessionDao.getTotalHoursInRange(startDate, endDate) ?: 0.0
    }

    fun getTimesheetRows(year: Int, month: Int): Flow<List<TimesheetRow>> {
        return getSessionsForMonth(year, month).map { sessions ->
            val startDate = LocalDate.of(year, month, 1)
            val endDate = startDate.with(TemporalAdjusters.lastDayOfMonth())
            val locale = Locale.GERMANY
            // Configured to ensure the 1st day of the month is ALWAYS "Week 1", never "Week 0".
            // We use Monday as start of week, and minimum 1 day in the first week.
            val weekFields = WeekFields.of(DayOfWeek.MONDAY, 1)
            
            // Batch fetch pauses for all sessions
            val sessionIds = sessions.map { it.id }
            val allPauses = if (sessionIds.isNotEmpty()) {
                pauseDao.getPausesForSessionIds(sessionIds)
            } else {
                emptyList()
            }
            val pausesBySession = allPauses.groupBy { it.sessionId }
            
            val allDates = generateSequence(startDate) { it.plusDays(1) }
                .takeWhile { !it.isAfter(endDate) }
                .toList()
            
            val sessionsByDate = sessions.groupBy { it.date }
            
            allDates.map { date ->
                val daySessions = sessionsByDate[date] ?: emptyList()
                val dayPauses = daySessions.flatMap { pausesBySession[it.id] ?: emptyList() }
                
                val dayOfWeek = date.dayOfWeek
                val dayName = dayOfWeek.getDisplayName(TextStyle.SHORT, locale)
                    .replace(".", "")
                    .replaceFirstChar { it.uppercase() }
                val isWeekend = dayOfWeek == DayOfWeek.SATURDAY || dayOfWeek == DayOfWeek.SUNDAY
                
                // Custom Week Numbering: 1-7 = Week 1, 8-14 = Week 2, etc.
                val weekNumber = (date.dayOfMonth - 1) / 7 + 1

                TimesheetRow(
                    date = date,
                    sessions = daySessions,
                    pauses = dayPauses,
                    dayName = dayName,
                    isWeekend = isWeekend,
                    weekNumber = weekNumber
                )
            }
        }
    }

    fun getWeeklySummaries(year: Int, month: Int): Flow<List<WeeklySummary>> {
        return getTimesheetRows(year, month).map { rows ->
            rows.groupBy { it.weekNumber }
                .map { (weekNum, weekRows) ->
                    WeeklySummary(
                        weekNumber = weekNum,
                        year = year,
                        totalHours = weekRows.sumOf { row -> 
                            row.sessions.sumOf { it.totalHours } 
                        },
                        daysWorked = weekRows.count { it.sessions.isNotEmpty() },
                        sessions = weekRows.flatMap { it.sessions }
                    )
                }
                .sortedBy { it.weekNumber }
        }
    }

    suspend fun checkForConflicts(session: Session): Boolean {
        // Check if times overlap
        if (session.startTime1 != null && session.stopTime1 != null) {
            if (session.startTime1.isAfter(session.stopTime1)) {
                return true
            }
        }
        if (session.startTime2 != null && session.stopTime2 != null) {
            if (session.startTime2.isAfter(session.stopTime2)) {
                return true
            }
        }
        if (session.stopTime1 != null && session.startTime2 != null) {
            if (session.stopTime1.isAfter(session.startTime2)) {
                return true
            }
        }
        return false
    }

    private fun calculateTotalHours(session: Session): Double {
        var totalMinutes = 0L
        
        // First period
        if (session.startTime1 != null && session.stopTime1 != null) {
            totalMinutes += java.time.Duration.between(
                session.startTime1, 
                session.stopTime1
            ).toMinutes()
        }
        
        // Second period
        if (session.startTime2 != null && session.stopTime2 != null) {
            totalMinutes += java.time.Duration.between(
                session.startTime2, 
                session.stopTime2
            ).toMinutes()
        }
        
        // Subtract pauses
        totalMinutes -= session.totalPauseDuration
        
        return totalMinutes / 60.0
    }

    companion object {
        fun formatTime(time: LocalTime?): String {
            return time?.format(DateTimeFormatter.ofPattern("HH:mm")) ?: "-"
        }

        fun formatDate(date: LocalDate): String {
            return date.format(DateTimeFormatter.ofPattern("dd.MM"))
        }

        fun formatHours(hours: Double): String {
            return if (hours > 0) String.format("%.2fh", hours) else "-"
        }

        fun formatPause(minutes: Long): String {
            return if (minutes > 0) String.format("%02d:%02d", minutes / 60, minutes % 60) else "-"
        }
    }
}
